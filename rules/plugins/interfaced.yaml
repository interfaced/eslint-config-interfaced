interfaced/camelcase: "error"
interfaced/caps-const: "error"
interfaced/event-const-desc: "error"
interfaced/event-const-value: "error"
interfaced/capitalized-enum: "error"
interfaced/capitalized-typedef: "error"
interfaced/interface-name-prefix: "error"
interfaced/abstract-class-name-prefix: "error"
interfaced/typecast-spacing: "error"
interfaced/prevent-unused-typedef-vars: "error"
interfaced/prevent-unused-meta-params: "error"

interfaced/no-empty-method: "error"
interfaced/no-public-underscore: "error"
interfaced/no-param-reassign: "error"
interfaced/no-unused-expressions: "error"
interfaced/no-tabs-in-jsdoc-type: "error"
interfaced/no-restricted-jsdoc-tags: ["error", {
  tags: [
    "inheritdoc",
    "public",
    {
        tag: "extends",
        allowWithTags: ["interface"],
        allowWithTypes: ["TypeApplication"] # Let use @extends for generics
    }
  ]
}]

interfaced/lines-between-methods: ["error", { amount: 1 }]
interfaced/lines-between-props: ["error", { amount: 1 }]
interfaced/lines-between-statics: ["error", { amount: 2 }]
interfaced/lines-around-class: ["error", { before: 2, after: 2, collisionPriority: "before" }]

interfaced/methods-order: ["error", { scopesOrder: ["public", "protected", "private"], staticInTheEnd: true }]
interfaced/props-order: ["error", { scopesOrder: ["public", "protected", "private"], constInTheEnd: true }]
interfaced/statics-order: ["error", { order: ["const", "enum", "typedef"] }]
interfaced/jsdoc-tags-order: ["error", {
  tagsOrder: [
    "deprecated",
    "template",
    "abstract",
    "virtual",
    "extends",
    "implements",
    "override",
    "suppress",
    "type",
    "this",
    "param",
    "return",
    "throws",
    "public",
    "protected",
    "private"
  ]
}]

interfaced/jsdoc-type-application-dot: ["error", "never"]
interfaced/jsdoc-type-indent: ["error", 4]
interfaced/jsdoc-type-spacing: ["error", {
  topBraces: "never",
  parens: "never",
  unaryOperator: "never",
  
  unionPipe: {
    before: "never",
    after: "never"
  },
  
  typeApplicationBrackets: "never",
  typeApplicationComma: {
    before: "never",
    after: "always"
  },
 
  recordBraces: "never",
  recordFieldComma: {
    before: "never",
    after: "always"
  },
  recordFieldColon: {
    before: "never",
    after: "always"
  },
  
  functionKeyword: "never",
  functionParens: "never",
  functionParamComma: {
    before: "never",
    after: "always"
  },
  functionParamColon: {
    before: "never",
    after: "always"
  },
  functionResultColon: {
    before: "never",
    after: "always"
  }
}]
interfaced/valid-jsdoc: ["error", {
  prefer: {
      arg: "param",
      argument: "param",
      returns: "return",
      throw: "throws" # Closure Compiler recognizes only @throws
  },
  preferType: {
      Boolean: "boolean",
      Number: "number",
      String: "string",
      object: "Object"
  },
  requireReturn: false,
  requireReturnType: true,
  requireParamType: true,
  requireReturnDescription: false,
  requireParamDescription: false
}]
interfaced/require-jsdoc: ["error", {
  require: {
    FunctionDeclaration: false,
    ArrowFunctionExpression: false,
    ClassDeclaration: true,
    MethodDefinition: true
  }
}]
interfaced/prefer-shorthand-jsdoc-types: ["error", {
  optionalParam: "always",
  nullableType: "always"
}]
